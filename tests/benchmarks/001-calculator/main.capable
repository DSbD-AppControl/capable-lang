{- Modelling and Realisation of a Calculator.
-}

role Client
role Server

type body = struct { x : Int; y : Int }

type command
  = union { adder : body
          ; suber : body
          ; diver : body
          ; muler : body
          }

type responsePure
  = union { answer : Int}

type responseEffect -- this is bad as not all commands cause div by zero
  = union { divByZero : Unit; answerE : Int}

type MaybeAnswer = union { crashed : Unit; result : Int }

protocol OneShotCalcutron
  = Client ==> Server [ command ]
    { adder(body)
        . Server ==> Client [ responsePure ] { answer(Int) . end}
    | suber(body)
        . Server ==> Client [ responsePure ] { answer(Int) . end}
    | diver(body)
       . Server ==> Client [ responseEffect ]
                   { divByZero(Unit) . end
                   | answerE(Int)    . end
                   }
    | muler(body)
       . Server ==> Client [ responsePure ] { answer(Int) . end}
    }

session calcutronServer
        <OneShotCalcutron as Server>
        () -> Bool
{
  recv [ command ] Client
  {
    when adder(xy)
    {
      send [responsePure] Client answer(add(get_x(xy),get_y(xy))) catch { crash(false) }
      end(true)
    }
    when suber(xy)
    {
      send [responsePure] Client answer(sub(get_x(xy),get_y(xy))) catch { crash(false) }
      end(true)
    }
    when diver(xy)
    {
      if lte(get_y(xy),0)
      {
        send [responseEffect] Client divByZero(unit) catch { crash(false) }
        end(false)
      } else
      {
        send [responseEffect] Client answerE(div(get_x(xy),get_y(xy))) catch { crash(false) }
        end(true)
      }
    }
    when muler(xy)
    {
      send [responsePure] Client answer(mul(get_x(xy),get_y(xy))) catch { crash(false) }
      end(true)
    }
  } catch { crash(false) }
}


session calcutronClientAdder
        <OneShotCalcutron as Client>
        (x : Int, y : Int) -> MaybeAnswer
{

  send [ command ] Server adder(body(x,y))
    catch { crash(crashed(unit)) }


  recv [ responsePure ] Server
  {
    when answer(i)
    {
      end(result(i))
    }
  } catch { crash(crashed(unit)) }
}

main()
{
  print("My First Program")
; print(toString('\n'))

}
